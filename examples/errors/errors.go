// Одна з ідіом Go, це отримувати помилки за допомогою чітко
// вказаних даних що повертаються (з функцій). Це виділяє Go
// на фоні _виключень_ (_exceptions_) що використовуються у
// Java чи Ruby, або в порівнянні з перевантаженням одиночного
// результату та помилки, що інколи використовується в С. Підхід Go,
// полегшує нагляд за функціями, що повертають помилки і
// обробляє їх (помилки) так само як і інші, не-помилкові, задачі.

package main

import "errors"
import "fmt"

// За погодженнням, помилкою вказується останнє,
// з значень що повертаються, що, надодачу має тип
// `error` (який є вбудованим інтерфейсом).
func f1(arg int) (int, error) {
    if arg == 42 {

        // Конструкція `errors.New` створює базове значення
        // помилки з заданим повідомленням.
        return -1, errors.New("can't work with 42")
    }

    // А `nil` значення на позиції помилки - вказує на те,
    // що ніякої помилки не виникло.
    return arg + 3, nil
}

// Можливо використовувати й інші типи як помилки (`error`s)
// (якщо ці типи реалізують метод `Error()` на собі).
// Ось приклад, що використовує власний тип помилки, що
// ясно репрезентує помилку значення переданого аргументом.
type argError struct {
    arg  int
    prob string
}

func (e *argError) Error() string {
    return fmt.Sprintf("%d - %s", e.arg, e.prob)
}

func f2(arg int) (int, error) {
    if arg == 42 {

        // У цьому випадку ми вкористовуємо синтакс `&argError`
        // щоб створити нову структуру забезпечуючи її значеннями
        // для двох полів `arg` та `prob`.
        return -1, &argError{arg, "can't work with it"}
    }
    return arg + 3, nil
}

func main() {

    // Ци два цикли тестують кожну знаших функцій що повертають
    // помилки. Зауважте, що перевірка помилки, поряд з оператором
    // умовного розгалуження `if`, це одна з ідіом Go.
    for _, i := range []int{7, 42} {
        if r, e := f1(i); e != nil {
            fmt.Println("f1 failed:", e)
        } else {
            fmt.Println("f1 worked:", r)
        }
    }
    for _, i := range []int{7, 42} {
        if r, e := f2(i); e != nil {
            fmt.Println("f2 failed:", e)
        } else {
            fmt.Println("f2 worked:", r)
        }
    }

    // Якщо ви хочете використати дані вашої помилки программно -
    // вам необхідно буде дістати помилку як зразок (instance) вашого
    // типу, використовуючи заяву типу (type assertion).
    _, e := f2(42)
    if ae, ok := e.(*argError); ok {
        fmt.Println(ae.arg)
        fmt.Println(ae.prob)
    }
}
